# Docker Compose Konfiguration
# ============================
# Diese Datei definiert eine Multi-Container-Umgebung mit Docker Compose.
# Version 3.8 bietet moderne Funktionen wie Health Checks und Deploy-Optionen.
#
# KONFIGURATION:
# Alle Umgebungsvariablen werden aus der .env-Datei geladen.
# Kopieren Sie .env.example nach .env und passen Sie die Werte an:
#   cp .env.example .env
#
# Variablen mit Standardwerten: ${VAR:-default}
# Variablen ohne Standard (Pflichtfelder): ${VAR}

# =============================================================================
# DIENSTE (Services)
# =============================================================================
# Hier werden alle Container definiert, die zusammen die Anwendung bilden.
# Jeder Dienst kann einen eigenen Container starten und konfigurieren.

services:
  # ---------------------------------------------------------------------------
  # Web-Anwendung
  # ---------------------------------------------------------------------------
  # Der Haupt-Webserver der Anwendung.
  # Beispiel: Node.js, Python Flask, PHP, etc.
  web:
    # Docker Image - hier ein generisches nginx als Beispiel
    # Ersetzen Sie dies durch Ihr eigenes Image oder verwenden Sie 'build'
    image: nginx:alpine

    # Container-Name für einfachere Identifikation
    container_name: app_web

    # Neustart-Richtlinie bei Fehlern oder System-Neustart
    # 'unless-stopped': Startet automatisch neu, außer manuell gestoppt
    restart: unless-stopped

    # Port-Mapping: Host:Container
    # Der Container-Port wird auf dem Host verfügbar gemacht
    ports:
      - "8080:80"    # Webserver auf Port 8080 erreichbar

    # Umgebungsvariablen für die Anwendung
    # Werte werden aus .env-Datei geladen (siehe .env.example)
    environment:
      - NODE_ENV=${NODE_ENV:-development}
      # Datenbank-Verbindung
      - DB_HOST=${DB_HOST:-db}
      - DB_PORT=${DB_PORT:-5432}
      - DB_NAME=${DB_NAME:-app_database}
      # E-Mail-Konfiguration (Mailhog für Testing)
      # Alle E-Mails werden von Mailhog abgefangen und in der Web-UI angezeigt
      - SMTP_HOST=${SMTP_HOST:-mailhog}
      - SMTP_PORT=${SMTP_PORT:-1025}

    # Volumes: Persistente Datenspeicherung und Code-Mounting
    # Bei Entwicklung: lokaler Code wird in Container gemountet
    volumes:
      - ./app:/usr/share/nginx/html:ro   # App-Dateien (read-only)
      - web_logs:/var/log/nginx          # Log-Dateien persistent speichern

    # Netzwerk-Zuordnung für Container-zu-Container-Kommunikation
    networks:
      - app_network

    # Abhängigkeit: Web-Container startet erst, wenn DB bereit ist
    depends_on:
      db:
        condition: service_healthy

    # Health Check: Überprüft, ob der Dienst korrekt funktioniert
    # Docker kann unhealthy Container automatisch neu starten
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/"]
      interval: 30s      # Prüfung alle 30 Sekunden
      timeout: 10s       # Timeout für einzelne Prüfung
      retries: 3         # Anzahl Fehlversuche bis 'unhealthy'
      start_period: 10s  # Wartezeit beim Start

  # ---------------------------------------------------------------------------
  # Datenbank
  # ---------------------------------------------------------------------------
  # PostgreSQL-Datenbank für die Anwendungsdaten.
  # Persistente Speicherung über benanntes Volume.
  db:
    # PostgreSQL als Beispiel-Datenbank
    # Alternativ: mysql, mariadb, mongodb, etc.
    image: postgres:15-alpine

    container_name: app_db

    restart: unless-stopped

    # Datenbank-Konfiguration über Umgebungsvariablen
    # Werte werden aus .env-Datei geladen (siehe .env.example)
    # WICHTIG: POSTGRES_PASSWORD muss in .env gesetzt werden!
    environment:
      - POSTGRES_USER=${POSTGRES_USER:-app_user}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB:-app_database}
      - PGDATA=${PGDATA:-/var/lib/postgresql/data/pgdata}

    # Datenbank-Port (nur intern im Netzwerk verfügbar)
    # Für externe Zugriffe: "5432:5432" verwenden
    expose:
      - "5432"

    # Persistente Datenspeicherung der Datenbank
    # Benanntes Volume für Datenerhalt bei Container-Neustart
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d:ro  # Init-Skripte

    networks:
      - app_network

    # Health Check für Datenbank-Verfügbarkeit
    # Verwendet die Container-Umgebungsvariablen ($$VAR wird zu $VAR im Container)
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # ---------------------------------------------------------------------------
  # E-Mail-Testing (Mailhog)
  # ---------------------------------------------------------------------------
  # Mailhog fängt alle ausgehenden E-Mails ab und stellt sie in einer Web-UI dar.
  # Ideal für Entwicklung und Testing, ohne echte E-Mails zu versenden.
  mailhog:
    # Mailhog Docker Image
    image: mailhog/mailhog:latest

    # Container-Name für einfachere Identifikation
    container_name: app_mailhog

    # Neustart-Richtlinie bei Fehlern oder System-Neustart
    restart: unless-stopped

    # Port-Mapping: Host:Container
    # SMTP-Port für E-Mail-Empfang und Web-UI für Anzeige
    ports:
      - "1025:1025"   # SMTP-Server für E-Mail-Versand
      - "8025:8025"   # Web-UI für E-Mail-Anzeige

    # Netzwerk-Zuordnung für Container-zu-Container-Kommunikation
    networks:
      - app_network

    # Health Check: Überprüft, ob die Web-UI erreichbar ist
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8025/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # ---------------------------------------------------------------------------
  # Datenbank-Verwaltung (Adminer)
  # ---------------------------------------------------------------------------
  # Adminer ist ein leichtgewichtiges Web-basiertes Datenbank-Management-Tool.
  # Ermöglicht einfache Verwaltung der PostgreSQL-Datenbank über den Browser.
  adminer:
    # Adminer Docker Image
    image: adminer:latest

    # Container-Name für einfachere Identifikation
    container_name: app_adminer

    # Neustart-Richtlinie bei Fehlern oder System-Neustart
    restart: unless-stopped

    # Port-Mapping: Host:Container
    # Adminer Web-UI auf Port 8081 (8080 ist bereits vom Web-Service belegt)
    ports:
      - "8081:8080"

    # Netzwerk-Zuordnung für Container-zu-Container-Kommunikation
    networks:
      - app_network

    # Abhängigkeit: Adminer startet erst, wenn DB bereit ist
    depends_on:
      db:
        condition: service_healthy

    # Health Check: Überprüft, ob die Web-UI erreichbar ist
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # ---------------------------------------------------------------------------
  # MQTT Broker (Eclipse Mosquitto)
  # ---------------------------------------------------------------------------
  # Eclipse Mosquitto ist ein leichtgewichtiger MQTT-Broker für IoT und Messaging.
  # Unterstützt MQTT und WebSocket mit TLS-Verschlüsselung.
  mosquitto:
    # Eclipse Mosquitto Docker Image
    image: eclipse-mosquitto:latest

    # Container-Name für einfachere Identifikation
    container_name: app_mosquitto

    # Neustart-Richtlinie bei Fehlern oder System-Neustart
    restart: unless-stopped

    # User-Mapping: Läuft als mosquitto user (UID 1883)
    user: "1883:1883"

    # Port-Mapping: Host:Container
    ports:
      - "${MQTT_PORT:-1883}:1883"       # MQTT unverschlüsselt
      - "${MQTT_TLS_PORT:-8883}:8883"   # MQTT mit TLS
      - "${MQTT_WS_PORT:-9001}:9001"    # WebSocket unverschlüsselt
      - "${MQTT_WSS_PORT:-8084}:8084"   # WebSocket mit TLS

    # Volumes: Konfiguration, Daten, Logs und Zertifikate
    volumes:
      - ./mosquitto/config:/mosquitto/config:ro
      - ./mosquitto/certs:/mosquitto/certs:ro
      - mosquitto_data:/mosquitto/data
      - mosquitto_logs:/mosquitto/log

    # Netzwerk-Zuordnung für Container-zu-Container-Kommunikation
    networks:
      - app_network

    # Health Check: Überprüft ob der Broker erreichbar ist
    healthcheck:
      test: ["CMD-SHELL", "mosquitto_sub -t '$$SYS/#' -C 1 -i healthcheck -W 3 || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # ---------------------------------------------------------------------------
  # Redis (Message Broker for MQTT-Dashboard Communication)
  # ---------------------------------------------------------------------------
  # Redis serves as pub/sub broker between MQTT client service and dashboard
  redis:
    image: redis:7-alpine
    container_name: app_redis
    restart: unless-stopped

    ports:
      - "${REDIS_PORT:-6379}:6379"

    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD:-}

    volumes:
      - redis_data:/data

    networks:
      - app_network

    healthcheck:
      test: ["CMD-SHELL", "redis-cli --no-auth-warning -a \"$$REDIS_PASSWORD\" ping || redis-cli ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 128M

    command: >
      sh -c "
      if [ -n \"$$REDIS_PASSWORD\" ]; then
        redis-server --requirepass \"$$REDIS_PASSWORD\" --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
      else
        redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
      fi
      "

  # ---------------------------------------------------------------------------
  # MQTT Dashboard (Web-basierte Verwaltung)
  # ---------------------------------------------------------------------------
  # Web-Dashboard für die Verwaltung und Überwachung des MQTT-Brokers.
  # Zeigt Broker-Statistiken, verbundene Clients, Topics und ermöglicht
  # das Veröffentlichen von Nachrichten über eine grafische Oberfläche.
  mqtt-dashboard:
    # Build-Kontext: Dockerfile im mqtt-dashboard Verzeichnis
    # Multi-Stage-Build: Vue.js Frontend + Python Flask Backend
    build:
      context: ./mqtt-dashboard
      dockerfile: Dockerfile

    # Container-Name für einfachere Identifikation
    container_name: app_mqtt_dashboard

    # Neustart-Richtlinie bei Fehlern oder System-Neustart
    restart: unless-stopped

    # Port-Mapping: Host:Container
    # Dashboard-Web-UI auf Port 8082
    ports:
      - "${MQTT_DASHBOARD_PORT:-8082}:5000"

    # Umgebungsvariablen für MQTT-Verbindung
    # Werte werden aus .env-Datei geladen (siehe .env.example)
    environment:
      # Flask-Konfiguration
      - FLASK_ENV=${FLASK_ENV:-production}
      - FLASK_DEBUG=${FLASK_DEBUG:-0}
      - SECRET_KEY=${SECRET_KEY}

      # MQTT-Broker-Verbindung
      - MQTT_BROKER_HOST=${MQTT_BROKER_HOST:-mosquitto}
      - MQTT_BROKER_PORT=${MQTT_BROKER_PORT:-1883}
      - MQTT_CLIENT_ID=${MQTT_CLIENT_ID:-mqtt-dashboard}
      - MQTT_KEEPALIVE=${MQTT_KEEPALIVE:-60}

      # MQTT-Authentifizierung (optional)
      - MQTT_USERNAME=${MQTT_USERNAME:-}
      - MQTT_PASSWORD=${MQTT_PASSWORD:-}

      # MQTT-TLS-Konfiguration (optional)
      - MQTT_USE_TLS=${MQTT_USE_TLS:-false}
      - MQTT_TLS_INSECURE=${MQTT_TLS_INSECURE:-false}

      # Redis-Konfiguration
      - REDIS_HOST=${REDIS_HOST:-redis}
      - REDIS_PORT=${REDIS_PORT:-6379}
      - REDIS_PASSWORD=${REDIS_PASSWORD:-}

      # WebSocket-Konfiguration
      - SOCKETIO_ASYNC_MODE=${SOCKETIO_ASYNC_MODE:-gevent}

    # Netzwerk-Zuordnung für Container-zu-Container-Kommunikation
    networks:
      - app_network

    # Abhängigkeit: Dashboard startet erst, wenn Mosquitto und Redis bereit sind
    depends_on:
      mosquitto:
        condition: service_healthy
      redis:
        condition: service_healthy

    # Health Check: Überprüft, ob das Dashboard erreichbar ist
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s

  # ---------------------------------------------------------------------------
  # MQTT Bridge Service (Standalone MQTT Client)
  # ---------------------------------------------------------------------------
  # Dedicated service that maintains MQTT connection and bridges to Redis.
  # Eliminates threading conflicts in dashboard workers.
  mqtt-bridge:
    build:
      context: ./mqtt-dashboard
      dockerfile: Dockerfile.mqtt-service

    container_name: app_mqtt_bridge

    restart: unless-stopped

    environment:
      # MQTT Configuration
      - MQTT_BROKER_HOST=${MQTT_BROKER_HOST:-mosquitto}
      - MQTT_BROKER_PORT=${MQTT_BROKER_PORT:-1883}
      - MQTT_USERNAME=${MQTT_USERNAME:-}
      - MQTT_PASSWORD=${MQTT_PASSWORD:-}

      # Redis Configuration
      - REDIS_HOST=${REDIS_HOST:-redis}
      - REDIS_PORT=${REDIS_PORT:-6379}
      - REDIS_PASSWORD=${REDIS_PASSWORD:-}

    networks:
      - app_network

    depends_on:
      mosquitto:
        condition: service_healthy
      redis:
        condition: service_healthy

    healthcheck:
      test: ["CMD", "python", "-c", "import os; from app.redis_client import RedisClient; r = RedisClient(host=os.environ.get('REDIS_HOST', 'redis'), port=int(os.environ.get('REDIS_PORT', '6379')), password=os.environ.get('REDIS_PASSWORD') or None); exit(0 if r.is_connected() else 1)"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s

    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 128M

# =============================================================================
# NETZWERKE (Networks)
# =============================================================================
# Eigene Netzwerke für isolierte Container-Kommunikation.
# Container im selben Netzwerk können sich über Namen erreichen.

networks:
  # Internes Netzwerk für die Anwendung
  app_network:
    driver: bridge
    # Optionale IP-Konfiguration:
    # ipam:
    #   config:
    #     - subnet: 172.20.0.0/16

# =============================================================================
# VOLUMES (Persistente Speicher)
# =============================================================================
# Benannte Volumes für Daten, die Container-Neustarts überleben sollen.
# Docker verwaltet diese Volumes automatisch.

volumes:
  # Datenbank-Daten
  db_data:
    driver: local

  # Web-Server Logs
  web_logs:
    driver: local

  # Mosquitto persistent data
  mosquitto_data:
    driver: local

  # Mosquitto logs
  mosquitto_logs:
    driver: local

  # Redis persistent data
  redis_data:
    driver: local

# =============================================================================
# ERWEITERUNG
# =============================================================================
# Um weitere Dienste hinzuzufügen:
# 1. Neuen Service-Block unter 'services' erstellen
# 2. Bei Bedarf zum 'app_network' hinzufügen
# 3. Volumes für persistente Daten definieren
# 4. depends_on für Abhängigkeiten setzen
#
# Beispiele für weitere Dienste:
# - redis: Cache-Server
# - nginx: Reverse Proxy / Load Balancer
# =============================================================================
